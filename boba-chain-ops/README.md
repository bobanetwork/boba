# boba-chain-ops

## boba-migrate
This package performs state regenesis. It takes the following input:

1. An `alloaction.json` file that contains a list of pre-allocated accounts.
2. A `genesis.json` file that contains the genesis block configuration.
3. A list of addresses that transacted on the network prior to this past regenesis.
4. A list of addresses that performed approvals on prior versions of the OVM ETH contract.
5. A list of msg information that stores the cross domain message from L2 to L1

It creates an initialized Bedrock erigon database as output. It does this by performing the following steps:

1. Create genesis (types.Genesis) from `genesis.json` and `allocation.json` in memory.
2. Set up the proxy contract for the predeploy contracts and update the bytecode of the predeploy contracts.
3. Migrate Boba legacy proxy implementation contract the new proxy contract and delete the slots
4. Migrate the ETH balance from the storage of OVM ETH contract to the balance field in genesis and delete the ETH balance storage slot.
5. Migrate the msg information from the storage of OVM_CrossDomainMessenger contract to the new slot.

It performs the following integrity checks:

1. OVM ETH storage slots must be completely accounted for.
2. The total supply of OVM ETH migrated must match the total supply of the OVM ETH contract.

### Compilation

Run `make boba-migrate`

## boba-rollover

This package performs state regenesis for creating a legacy chain in erigon. The new chain is only readable and is not compatible with v3. It takes the following input:

1. An `alloaction.json` file that contains a list of pre-allocated accounts.
2. A `genesis.json` file that contains the genesis block configuration.

3. A list of addresses that transacted on the network prior to this past regenesis.

It creates an initialized erigon database as output. It does this by performing the following steps:

1. Migrate the ETH balance from the storage of OVM ETH contract to the balance field in genesis and delete the ETH balance storage slot.

It performs the following integrity checks:

1. OVM ETH storage slots must be completely accounted for.
2. The total supply of OVM ETH migrated must match the total supply of the OVM ETH contract.

### Compilation

Run `make boba-rollover`

## boba-regenerate

This pacakge performs the chain regeneration via calling engine api. It does this by performing the following steps:

1. Call the legacy block chain to get the block and transaction information.
2. Build `PayloadAttributes` and call `engine_forkchoiceUpdatedV1` to get `PayloadID`
3. Call `engine_getPayloadV1` with the `PayloadID` from the last step to get `executionPayload`
4. Call `engine_newPayloadV1` with the `executionPayload` to execute the transaction
5. Call `engine_forkchoiceUpdatedV1` to build the block

It performs the following integrity checks:

1. The block hash and transaction hash must match the legacy block chain

### Compilation

Run `make boba-regenerate`

## boba-crawler

This package performs the process of getting addresses that send or receive ETH from the legacy block chain. It does this by performing the following steps:

1. Call `debug_traceTransaction` to find out addresses that send and receive ETH from internal transactions.
2. Call `eth_getLogs` to find out addresses that receive ETH from the ` ETH Mint` event

It performs the following integrity checks:

1. The address list can be used to compute the all storage keys of `OVM_ETH` contract from the allocation file.

### Compilation

Run `make boba-crawler`

## boba-devnet

This package generates a clean genesis file for devent. It only includes the predeployed contracts for L2. It takes the following input to generate the genesis file:

1. The deployment configuration for the l2
2. The hardhat deployment path
3. The l1 PRC endpoint for quering the block information

### Compilation

Run `make boba-devnet`

## boba-connect

This package generates a transition block between the legacy and new systems. It does this by performing the following steps:

1. A configuration file to get the timestamp of the transition block.
2. Use the engine api to create an empty block with the right block timestamp

### Compilation

Run `make boba-connect`

# Migration

## Before the migration

Before the actual migration, we first need a `witness.txt` file including all L2 cross chain messages. Thie `withness.txt` file can be generated by geth client. In geth client (replica), add the following environment variable:

```go
environment:
  L2GETH_STATE_DUMP_PATH: "/dump/witness.txt"
volumes:
  - VOLUME_LOCATION:/dump
```

We also need an  `eth-addresses.json` file inlcuding all addresses that have transferred or received ETH in the legacy system. This file is used to rebuild the balances of accounts into the state rather than keeping in the storage of the `OVM_ETH` contract. To get the `eth-addresses.json`, run the `boba-crawler` to crawl the addresses from `debug_traceTransaction` and `eth_getLogs`.

```bash
go run ./cmd/boba-crawler --rpc-url=LEGACY_RPC --output-path=OUTPUT_ETH_ADDRESSES
```

We can deploy the new L1 smart contracts first. To deploy new smart contracts, we should copy and paste deployment files to `packages/contracts-bedrock/deployment` and change the folder name to the network type, such as `boba-goerli`. We then create a configuration file for the v3. The configuration file should be this:

```go
{
  "numDeployConfirmations": 1,
	
  // The final contract owner of ProxyAdmin
  "finalSystemOwner": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266",
  // The admin can pause deposits and withdrawals of OptimismPortal
  "portalGuardian": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266",
  // The admin controls the upgrade of SystemDictator
  "controller": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266",

  // This is the actual block hash of L1
  "l1StartingBlockTag": "0x9e23050bde8767414b4388420f160c324438f9238f88a478d027e0d6728f5ed2",

  "l1ChainID": 910,
  "l2ChainID": 911,
  "l2BlockTime": 2,
	
  // How far the L2 timestamp can differ from the L1 timestamp. If our next l2 block timestamp is beyond the drift threshold, op-rollup produces the empty blocks to catch up the timestamp
  "maxSequencerDrift": 600,
  // Maximum number of L1 blocks that a Sequencer can wait to incorporate the information in a specific L1 block.
  "sequencerWindowSize": 3600,
  // Maximum number of L1 blocks that a transaction channel frame can be considered valid. A transaction channel frame is a chunk of a compressed batch of transactions.
  "channelTimeout": 300,
	
  // Address of the key that the Sequencer uses to sign blocks on the p2p network.
  "p2pSequencerAddress": "0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc",
  // The target address for the sequencer batch
  "batchInboxAddress": "0xff00000000000000000000000000000000000420",
  // The sender address for the sequencer batch
  "batchSenderAddress": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266",

  // The number of blocks that we send the proposal to L1 `L2OutputOracle`
  "l2OutputOracleSubmissionInterval": 120,
  // The starting block of the bedrock
  // This is super IMPORTANT!!!
  "l2OutputOracleStartingBlockNumber": 41,
  // This is the timetamp of the l1StartingBlockTag
  "l2OutputOracleStartingTimestamp": 1687907471,
	
  // The proposer address
  "l2OutputOracleProposer": "0x70997970C51812dc3A010C7d01b50e0d17dc79C8",
  // The admin address can challenge the proposals submitted to L1 `L2OutputOracle`
  "l2OutputOracleChallenger": "0x70997970C51812dc3A010C7d01b50e0d17dc79C8",

  // Fraud-proof window
  // This should be 7 days in the real production
  "finalizationPeriodSeconds": 12,

  // The admin address of the L2 ProxyAdmin contract
  "proxyAdminOwner": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266",
  "baseFeeVaultRecipient": "0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC",
  "l1FeeVaultRecipient": "0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC",
  "sequencerFeeVaultRecipient": "0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC",

  "gasPriceOracleOverhead": 2100,
  "gasPriceOracleScalar": 1000000,

  "governanceTokenSymbol": "OP",
  "governanceTokenName": "Optimism",
  "governanceTokenOwner": "0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266",

  "l2GenesisBlockGasLimit": "0x17D7840",
  "l2GenesisBlockBaseFeePerGas": "0x3b9aca00",

  "eip1559Denominator": 50,
  "eip1559Elasticity": 10,
	
  // Replace this to the actual L1 BOBA token address
  "l1BobaTokenAddress": "0x1613beB3B2C4f22Ee086B2b38C1476A3cE7f78E8"
}
```

> Note: the variable explanation can be found in `docs/op-stack/src/docs/build/conf.md`

The configuration file should be renamed as the network name and stored in `packages/contracts-bedrock/deploy-config`, such as `boba-goerli.json`. Another ts file is required to export the configuration file. An example is

```tsx
import { DeployConfig } from '../src/deploy-config'
import config from './network-name.json'

export default config satisfies DeployConfig
```

Then we add the network information to the `hardhat.config.ts`. Once all files are in the place, we delete some deploy files in the `deploy` folder and only keep files named from `000` to `019`. This will only deploy the new contratcs, but not upgrading the current contracts to the new contracts.

> At this point, the legacy system can still work. The contract deployments don't affect the any code in the legacy system.

## Set the timestamp of transition block

Once we decide to upgrade to v3 anchorage, we choose a L1 block which is usually the latest one and replace the block hash and the timestamp in the above configuration file. Then we add back the deployment scripts called `020` and `021` and finalize the L1 contract deployment.

## DB migration

Before starting the v3 anchorage, we migrate the all legacy transactions to erigon. This processs requires a specific erigon version to accept transactions from the engine api. This specific erigon is under the `boba-bedrock-hardfork` branch. https://github.com/bobanetwork/v3-erigon/tree/boba-bedrock-hardfork

We create a new DB for erigon first. The network inforamtion should be added to `boba-migrate`. The network information should be added to these few places in `boba-chain-ops`.

* `boba-chain-ops/chain/chain.go`

  For example:

  ```go
  // Boba Goerli
  BobaGoerliChainId = big.NewInt(2888)
  // Boba Goerli genesis gas limit
  BobaGoerliGenesisGasLimit = 11000000
  // Boba Goerli genesis block coinbase
  BobaGoerliGenesisCoinbase = "0x0000000000000000000000000000000000000000"
  // Boba Goerli genesis block extra data
  // DON'T ADD 0x as the prefix
  BobaGoerliGenesisExtraData = "000000000000000000000000000000000000000000000000000000000000000000000398232e2064f896018496b4b44b3d62751f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
  // Boba Goerli genesis root
  BobaGoerliGenesisRoot = "0x36c808dc3bb586c14bebde3ca630a4d49a1fdad0b01d7e58f96f2fcd1aa0003d"
  // Boba Goerli genesis block hash
  BobaGoerliGenesisBlockHash = "0xde36bac664c1215f9a7d87cddd3745594b351d3464e8a624e322eddd59ccacf3"
  // Goerli L1 BOBA Address
  BobaTokenGoerliL1Address = "0xeCCD355862591CBB4bB7E7dD55072070ee3d0fC1"
  
  // Add the network logic to the following code...
  ```

* `boba-chain-ops/crossdomain/params.go`

  For example:

  ```go
  var ParamsByChainID = map[int]*Params{
  	288: {
  		new(big.Int),
  	}
  }
  ```

* `boba-chain-ops/genesis/setters.go` 

  For example:

  ```go
  // UntouchableCodeHashes represent the bytecode hashes of contracts
  // that should not be touched by the migration process.
  UntouchableCodeHashes = map[common.Address]ChainHashMap{
  	predeploys.BobaL2Addr: {
  	// 1: common.HexToHash("0x8551d935f4e67ad3c98609f0d9f0f234740c4c4599f82674633b55204393e07f"),
  	2888: common.HexToHash("0xbaf64deb0d9e918626165a29068dfe0e69262b7b5bf17ded21cf0810fa425e6a"),
  	},
  	predeploys.WETH9Addr: {
  		288:  common.HexToHash("0x5b4b51d84d1f4b5bff7e20e96ed0771857d01c15aee81ff1eb34cf75c25e725e"),
  		2888: common.HexToHash("0x5b4b51d84d1f4b5bff7e20e96ed0771857d01c15aee81ff1eb34cf75c25e725e"),
  	},
  }
  ```

  The code hash is used to verify that the contract we create in DB is the same as what we provide in the allocation file.

The network information should be added to `v3-erigon-lib`. The specific branch for the migration is: https://github.com/bobanetwork/v3-erigon-lib/tree/boba-bedrock-hardfork. The code should be added to https://github.com/bobanetwork/v3-erigon-lib/blob/7514116780a5181c16fa83bedb5e99de448ac46c/chain/chain_config.go#L36. For example:

```go
// Goerli
BobaGoerliChainId = big.NewInt(2888)
BobaGoerliBedrockBlock = big.NewInt(9000)
BobaGoerliBedrockTime = uint64(1680826751)
// Boba Goerli genesis gas limit
BobaGoerliGenesisGasLimit = 11000000
// Boba Goerli genesis block coinbase
BobaGoerliGenesisCoinbase = "0x0000000000000000000000000000000000000000"
// Boba Goerli genesis block extra data
BobaGoerliGenesisExtraData = "000000000000000000000000000000000000000000000000000000000000000000000398232e2064f896018496b4b44b3d62751f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
// Boba Goerli genesis root
BobaGoerliGenesisRoot = "0x36c808dc3bb586c14bebde3ca630a4d49a1fdad0b01d7e58f96f2fcd1aa0003d"

// Add the network logic to the following code...
```

> !!IMPORTANT!!
>
> The erigon-lib that erigon imports should be updated to the latest one. https://github.com/bobanetwork/v3-erigon/blob/adc49cc874439fd5d649bac25683c09496648bc5/go.mod#L275

Once finishing the code changes, we can build the docker image for the `boba-chain-ops` and `erigon-spec` for the later usages.

The allocation file of the old geth DB is required to create the initial state of the genesis block. The allocation file is generated by `geth-dump` in `op-chain-ops/cmd/geth-dump`.

```bash
go run ./cmd/geth-dump --db-path=GETH_DB --output-path=ALLOCATION_OUTPUT
```

> We can run the following command to verify that `eth-addresses.json` can create all storages of `OVM_ETH`
>
> ```bash
> go run ./cmd/boba-crawler --rpc-url=LEGACY_RPC --output-path=OUTPUT_ETH_ADDRESSES --alloc-path=ALLOCATION_FILE_LOCATION --post-check-only=true
> ```

Once we get the all these files, we need to create two empty files called `eth-allowance.json` (This problems occcur on Mainnnet which has the v1 legacy system that users can transfer ETH via the `OVM_ETH` contract) and `ovm-message.json`. Also, a l2 genesis file is needed. For example:

```json
{
  "config": {
    "chainId": 911,
    "homesteadBlock": 0,
    "eip150Block": 0,
    "eip150Hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
    "eip155Block": 0,
    "eip158Block": 0,
    "byzantiumBlock": 0,
    "constantinopleBlock": 0,
    "petersburgBlock": 0,
    "istanbulBlock": 0,
    "muirGlacierBlock": 0,
    "berlinBlock": 0,
    "londonBlock": 0,
    "arrowGlacierBlock": 0,
    "grayGlacierBlock": 0,
    "mergeNetsplitBlock": 0,
    "bedrockBlock": 41,
    "terminalTotalDifficulty": 0,
    "terminalTotalDifficultyPassed": true,
    "optimism": {
      "eip1559Elasticity": 2,
      "eip1559Denominator": 8
    }
  },
  "nonce": "0x0",
  "timestamp": "0x6372E51B",
  "extraData": "0x424544524f434b",
  "gasLimit": "0xa7d8c0",
  "difficulty": "0x0",
  "mixHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "coinbase": "0x4200000000000000000000000000000000000011",
  "alloc":{},
  "number": "0x0",
  "gasUsed": "0x0",
  "parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "baseFeePerGas": "0x3b9aca00"
}
```

> !! IMPORTANT !!
>
> bedrockBlock must be the block number of transition block between the legacy and new systems

Then we use `boba-migrate ` to generate the genesis block.

```bash
go run ./cmd/boba-migrate --l1-rpc-url=L1_RPC --db-path=ERIGON_DB_PATH --alloc-path=ALLOCATION_PATH --genesis-config-path=GENESIS_FILE --ovm-addresses=ETH_ADDRESSES_FILE --ovm-allowances=ETH_ALLOWANCE_FILE --witness-file=WITNESS_FILE --deploy-config=CONFIGURATION_FILE --network=NETWORK_NAME --hardhat-deployments=HARDHAT_DEPLOYMENT_FOLDER --outfile-rollup=ROLLUP_OUTPUT_PATH  --ovm-messages=OVM_MESSAGE_FILE
```

The above command creates the initial DB and a rollup configuration file for `op-node`. 

>!! IMPORTANT !!
>
>We need some extra changes for the rollup.json file after generating the transistion block

## Blockchain regeneration

We can start the `erigon-spec` with the above DB. The following environment variable is needed.

```
environment:
	ROLLUP_HISTORICAL_RPC_ENDPOINT: "LEGACY_RPC_ENDPOINT"
```

The `erigon-spec` loads the transaction and receipt information from the historical RPC endpoint and writes it to DB.

Ideally, you should see the erigon starts as usuall and waits for the incoming transactions. We then launch `boba-regenerate` to recreate the blockchain.

```go
go run ./cmd/boba-regenerate --l2-private-endpoint=L2_PRIVATE_RPC --l2-public-endpoint=L2_PUBLIC_RPC --l2-legacy-endpoint=L2_LEGACY_RPC --jwt-secret-path=JWT_PATH --hard-fork-block-number=HARDFORK_BLOCK
```

The above command uses the engine api to communicate with erigon and recreate the blockchain. Once the erigon reaches the last block of the legacy system, we take down the `erigon-spec` and start the standard `erigon` to continue the process. As usual, you should see the erigon starts as usual.

> If you see any errors about DB, please check the name of broken DB. If it's the txpool, you can delete the file folder in the erigon DB and restart the system. If it's the chaindata, then something goes wrong with the migration.

## Connect v2 and v3

We run the `boba-connect` to create a transition block between the legacy and new ones. 

```bash
go run ./cmd/boba-connect --jwt-secret-path=JWT_PATH --deploy-config=CONFIGURATION_PATH
```

> The timestamp in the configuration file must be correct! It's the starting block of the anchorage and should be same as `l2OutputOracleStartingTimestamp`

The final step is to modify `rollup.json` for the op-node before starting it. The block hash and block number of l2 should be changed to the information of the transition block.

## Reduce blank blocks

To reduce the blank blocks after the migration, we will create the blockchain before reaching the final migration block. This means that the genesis block we create for this DB is not correct. We will migrate the blockchain data from this DB to the new one after we can get the right `allocation` file for the genesis block.

> This procedure can reduce the waiting time of getting the genesis block before launching the erigon and op-node into few minutes.

## Abort migration 

We can restore the legacy system by resetting the addresses in `Lib_AddressManager` and restoring the implementation contracts of the proxy contracts.

* Register following contracts

  ```json
  {
    "OVM_CanonicalTransactionChain",
    "OVM_L2CrossDomainMessenger",
    "OVM_DecompressionPrecompileAddress",
    "OVM_Sequencer",
    "OVM_Proposer",
    "OVM_ChainStorageContainer-CTC-batches",
    "OVM_ChainStorageContainer-CTC-queue",
    "OVM_CanonicalTransactionChain",
    "OVM_StateCommitmentChain",
    "OVM_BondManager",
    "OVM_ExecutionManager",
    "OVM_FraudVerifier",
    "OVM_StateManagerFactory",
    "OVM_StateTransitionerFactory",
    "OVM_SafetyChecker",
    "OVM_L1MultiMessageRelayer",
    "BondManager"
  }
  ```

* Update the following implementation contracts

  ```json
  {
  	"Proxy__L1CrossDomainMessenger",
  	"Proxy__L1StandardBridge"
  }
  ```

  
